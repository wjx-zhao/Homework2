# 41243201 
# 41243203

作業二

本作業要求實現Max/Min Heap、Binary Search Tree、exercise 1

---  

# **Max/Min Heap**

## 題目要求
- 撰寫一個 C++ 抽象類別，類似於 ADT 5.2 中的 ADT MinPQ，該類別定義一個最小優先佇列接著，撰寫一個從此抽象類別衍生出來的 C++ 類別 MinHeap，並實作 MinPQ 中所有虛擬函式每個函式的複雜度應該和對應的 MaxHeap 函式相同。 
  
## 解題說明

## 程式實作

以下為主要程式碼：  
使用的標頭  
```cpp

```
 
```cpp

```

  
```cpp

``` 
  
```cpp

```  
  
  
```cpp


```  
  

```cpp

```



## 測試與驗證

### 測試案例



### 測試結果範例  




## 申論及開發報告

1. 

2.

3.



# **Binary Search Tree**

## 題目要求
-(a)寫一個程式，從一棵最初為空的二元搜尋樹（BST）開始，並進行 n 筆隨機插入。
使用均勻隨機數產生器來產生要插入的值。
接著，量測最終得到的二元搜尋樹的高度，並將此高度除以log2𝑛對於以下 n 值進行測試：
n=100,500,1000,2000,3000,…,10,000。
-(b)
寫一個 C++ 函式，從二元搜尋樹中刪除鍵值為 k 的節點，並說明這個函式的時間複雜度。
## 解題說明
- 
## 程式實作

以下為主要程式碼：
這是使用到的標頭檔  
```cpp


```

```cpp

```

```cpp


```

```cpp

```

```cpp

```

## 效能分析

### 時間複雜度  
Average Case = $O(nlogn)$  
- 當 pivot 每次大致能把子陣列對半分割，遞迴深度 ≈ $log n$ ，且每層需 $O(n)$ 處理，所以為 $O(nlogn)$  
- 分析: $Ta(n)$ = $2Ta(n/2)$ + $cn% ⇒ $Ta(n)$ = $O(nlogn)$  

Worst Case = $O(n²)$  
- 每次選擇的 pivot 恰好是子陣列的最小值，導致分割不平衡。左子陣列長度為 0，右子陣列長度為 $n−1$
- 分析: $Tw(n)$ = $Tw(n-1)$ + $cn$ ⇒ $Tw(n)$ = $O(n²)$  


## 測試與驗證

### 測試案例



### 測試結果範例




## 申論及開發報告

1.

2.

3.

# **exercise 1**

## 題目要求
-(a)有 n 筆記錄要在一台電腦上進行排序，該電腦的記憶體容量為 S 筆記錄（且S≪n）。假設整個 S-筆記錄的容量可用作輸入/輸出緩衝區。輸入資料位於磁碟上，總共分成 m 個 runs。
假設每次進行磁碟存取時，搜尋時間為ts，延遲時間為tl，每筆記錄的傳輸時間為tt。
若使用 k-路合併、並將內部記憶體分區作為輸入/輸出緩衝區（以允許輸入、輸出及 CPU 處理重疊，類似於 Buffering 中所述的方式（程式 7.21）），請問 phase two（外部排序的第二階段）的總輸入時間是多少？
-(b)
假設合併所有 runs 的 CPU 所需時間為 tCPU（我們假設它與 k 無關，因此為常數）。給定：𝑡𝑠=80ms,𝑡𝑙=20ms,𝑛=200,000,𝑚=64,𝑡𝑡=10^−3秒/筆記錄S=2000
請大略繪製總輸入時間  t input 與k 的關係圖。並回答：是否永遠存在某個k 值，能使 t CPU≈t input？

## 解題說明
- 


## 程式實作

以下為主要程式碼：
這是使用到的標頭檔  

```cpp

``` 
 
```cpp
  
```cpp


```

```cpp

```

```cpp


```

```cpp

```

## 效能分析

### 時間複雜度


## 測試與驗證

### 測試案例



### 測試結果範例  




## 申論及開發報告
1.

2.  

3.  



